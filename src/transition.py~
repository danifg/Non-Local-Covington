import random

"""
Implementation of transition systems.

The TransitionSystem class is an "interface" for all of the
subclasses that are being used, but isn't really used anywhere
explicitly itself.
"""

class TransitionSystem(object):
    def __init__(self, mappings, invmappings):
        self.mappings, self.invmappings = mappings, invmappings

    def _preparetransitionset(self, parserstate):
        """ Prepares the set of gold transitions given a parser state """
        raise NotImplementedError()

    def advance(self, parserstate, action):
        """ Advances a parser state given an action """
        raise NotImplementedError()

    def goldtransition(self, parserstate, goldrels):
        """ Returns the next gold transition given the set of gold arcs """
        raise NotImplementedError()

    def trans_to_str(self, transition, state, pos, fpos=None):
        raise NotImplementedError()

    @classmethod
    def trans_from_line(self, line):
        raise NotImplementedError()

    @classmethod
    def actions_list(self):
        raise NotImplementedError()



class Covington(TransitionSystem):
    @classmethod
    def actions_list(self):
        return [ 'NoArc', 'Shift', 'Left-Arc', 'Right-Arc']

    def create_cycles(self, parserstate, h, d):
        head = parserstate.head
        ##print('head',h)
        ##print('dep',d)
        n = h
        
        if n == d:
            #print 'cycle' 
            return True 
        
        while n > 0:
            ##print('n',n)
            n = head[n][0]
            if n == d:
                #print 'cycle' 
                return True 
        #exit()    
        return False

    def _preparetransitionset(self, parserstate):
        NOARC = self.mappings['action']['NoArc']
        SHIFT = self.mappings['action']['Shift']
        LEFTARC = self.mappings['action']['Left-Arc']
        RIGHTARC = self.mappings['action']['Right-Arc']
        
        list1, list2, buf, head = parserstate.list1, parserstate.list2, parserstate.buf, parserstate.head

        t = []
        
        if len(buf) != 0:
            
            if len(list1) == 0:
                t += [(SHIFT, -1)]
            else:  
                t += [(NOARC, -1)]
                t += [(SHIFT, -1)]
                if list1[len(list1)-1] != 0 and head[list1[len(list1)-1]][0] < 0 and not self.create_cycles(parserstate, head[buf[0]][0], list1[len(list1)-1]):
                    t += [(LEFTARC,)]
            
                if head[buf[0]][0] < 0 and not self.create_cycles(parserstate, head[list1[len(list1)-1]][0], buf[0]):
                    t += [(RIGHTARC,)]
                
        ##print '======================================================'   
        #print 'allowed trans'
        #print t    
        #print head
        """##print 'para config'
        ##print 'lista1'
        ##print list1
        ##print 'lista2'
        ##print list2
        ##print 'buffer'
        ##print buf
        """
        parserstate._transitionset = t
    
    
        
    def advance(self, parserstate, action):
        NOARC = self.mappings['action']['NoArc']
        SHIFT = self.mappings['action']['Shift']
        LEFTARC = self.mappings['action']['Left-Arc']
        RIGHTARC = self.mappings['action']['Right-Arc']
        

        RELS = len(self.mappings['rel'])
        cand = parserstate.transitionset()

       
        
        if isinstance(action, int):
           a, rel = self.tuple_trans_from_int(cand, action)
        else:
           rel = action[-1]
           a = action[:-1]

        list1 = parserstate.list1
        list2 = parserstate.list2
        buf = parserstate.buf
        
        """print 'USAN ADVANCE sobre'
        print 'lista1'
        print list1
        print 'lista2'
        print list2
        print 'buffer'
        print buf"""
        
        if a[0] == LEFTARC:
            #print 'LA'
            n = len(list1)-1 
            parserstate.head[list1[n]] = [buf[0], rel]
            parserstate.list2 = [list1[n]]+list2
            parserstate.list1 = list1[:n]
        elif a[0] == RIGHTARC:
            #print 'RA'
            n = len(list1)-1 
            parserstate.head[buf[0]] = [list1[n], rel]
            parserstate.list2 = [list1[n]]+list2
            parserstate.list1 = list1[:n]
        
        elif a[0] == SHIFT:# or len(list1) == 1:
            #print 'SH'
            parserstate.list1 = list1+list2+[buf[0]]
            parserstate.list2 = [];
            parserstate.buf = buf[1:]
        else:
            #print 'NA o avanza'
            n = len(list1)-1
            parserstate.list2 = [list1[n]]+list2
            parserstate.list1 = list1[:n]
            
        """ print 'DESPUES ADVANCE sobre'
        print 'lista1'
        print parserstate.list1
        print 'lista2'
        print parserstate.list2
        print 'buffer'
        print parserstate.buf"""    
        
        self._preparetransitionset(parserstate)

    def goldtransition(self, parserstate, goldrels=None):
        NOARC = self.mappings['action']['NoArc']
        SHIFT = self.mappings['action']['Shift']
        LEFTARC = self.mappings['action']['Left-Arc']
        RIGHTARC = self.mappings['action']['Right-Arc']
        

        goldrels = goldrels or parserstate.goldrels
        list1 = parserstate.list1
        list2 = parserstate.list2
        buf = parserstate.buf
        head = parserstate.head

        r = buf[0]
        addedArc = False
        noleftchildren = True
        for x in list1:
            if x in goldrels[r]:
                noleftchildren = False
                break    
        
        
        norighthead = True
        for x in list1:
            if r in goldrels[x]:
                norighthead = False
                break
        
        
        
        if len(list1) == 0:
            a = (SHIFT, -1)
            return a
            
        
        l = list1[len(list1)-1]     
        if l in goldrels[r]:
            rel = goldrels[r][l]
            a = (LEFTARC, rel)
            ###print 'LA'
        elif r in goldrels[l]:
            rel = goldrels[l][r]
            a = (RIGHTARC, rel)
            ###print 'RA'
        elif norighthead and noleftchildren:
            a = (SHIFT, -1)
            ###print 'SH'
        else:
            a = (NOARC, -1)
            ###print 'NA'

        ###print 'applyied tran'
        ###print a    
        return a

    def trans_to_str(self, t, state, pos, fpos=None):
        NOARC = self.mappings['action']['NoArc']
        SHIFT = self.mappings['action']['Shift']
        LEFTARC = self.mappings['action']['Left-Arc']
        RIGHTARC = self.mappings['action']['Right-Arc']
        if t[0] == SHIFT:
            if fpos is None:
                return "Shift\t%s" % (pos[state.buf[0]])
            else:
                return "Shift\t%s\t%s" % (pos[state.buf[0]], fpos[state.buf[0]])
        elif t[0] == LEFTARC:
            return "Left-Arc\t%s" % (self.invmappings['rel'][t[1]])
        elif t[0] == RIGHTARC:
            return "Right-Arc\t%s" % (self.invmappings['rel'][t[1]])
        elif t[0] == NOARC:
            return "NoArc"

    @classmethod
    def trans_from_line(self, line):
        if line[0] == 'Left-Arc':
            fields = { 'action':line[0], 'rel':line[1] }
        elif line[0] == 'Right-Arc':
            fields = { 'action':line[0], 'rel':line[1] }
        elif line[0] == 'Shift':
            fields = { 'action':line[0], 'pos':line[1] }
            if len(line) > 2:
                fields['fpos'] = line[2]
        elif line[0] == 'NoArc':
            fields = { 'action':line[0] }        
        else:
            raise ValueError(line[0])
        return fields
    

    def tuple_trans_to_int(self, cand, t):
        NOARC = self.mappings['action']['NoArc']
        SHIFT = self.mappings['action']['Shift']
        LEFTARC = self.mappings['action']['Left-Arc']
        RIGHTARC = self.mappings['action']['Right-Arc']
        

        RELS = len(self.mappings['rel'])

        base = 0
        
        if t[0] == NOARC:
            return base

        base += 1


        
        if t[0] == SHIFT:
            return base

        base += 1

        if t[0] == LEFTARC:
            return base + t[1]

        base += RELS

        if t[0] == RIGHTARC:
            return base + t[1]

    def tuple_trans_from_int(self, cand, action):
        NOARC = self.mappings['action']['NoArc']
        SHIFT = self.mappings['action']['Shift']
        LEFTARC = self.mappings['action']['Left-Arc']
        RIGHTARC = self.mappings['action']['Right-Arc']
        RELS = len(self.mappings['rel'])
        rel = -1
        
        base = 0
        if action == base:
            a = (NOARC, -1)
        base += 1

        if action == base:
            a = (SHIFT, -1)
        base += 1

        if base <= action < base + RELS:
            a = (LEFTARC,)
            rel = action - base
        base += RELS

        if base <= action < base + RELS:
            a = (RIGHTARC,)
            rel = action - base

        return a, rel








class NewCovington(TransitionSystem):
    @classmethod
    def actions_list(self):
        return [ 'Shift', 'Left-Arc', 'Right-Arc']

    def create_cycles(self, parserstate, h, d):
        head = parserstate.head
        #print('head',h)
        #print('dep',d)
        n = h
        
        if n == d:
            #print('cycle',n,d)  
            return True 
        
        while n > 0:
            ##print('n',n)
            n = head[n][0]
            if n == d:
                #print('cycle', n,d) 
                return True 
        #exit()    
        return False

    def _preparetransitionset(self, parserstate):
        SHIFT = self.mappings['action']['Shift']
        LEFTARC = self.mappings['action']['Left-Arc']
        RIGHTARC = self.mappings['action']['Right-Arc']
        
        list1, list2, buf, head = parserstate.list1, parserstate.list2, parserstate.buf, parserstate.head

        t = []
        #print '======================================================'
        if len(buf) != 0:
            
        
            #print 'para config'
            """print 'lista1'
            print list1
            print 'lista2'
            print list2
            print 'buffer'
            print buf
            """            
            if len(list1) == 0:
                t += [(SHIFT, -1)]
            else:  
                t += [(SHIFT, -1)]
                
                
                for si in xrange(len(list1)):
                    n = len(list1)-1
                    li = n - si
                    #print('LAAAA',si, li, n)
                    if list1[li] != 0 and head[list1[li]][0] < 0 and not self.create_cycles(parserstate, head[buf[0]][0], list1[li]):
                        t += [(LEFTARC, si)]
                        #break
                    
                for si in xrange(len(list1)):
                    n = len(list1)-1
                    li = n - si
                    
                    if head[buf[0]][0] < 0 and not self.create_cycles(parserstate, head[list1[li]][0], buf[0]):
                        #print(list1[li],'->',buf[0])
                        #print('RAAAA',si, li, n)
                        t += [(RIGHTARC, si)]
                        #break
                
           
        """print 'allowed trans'
        print t    
        print head
        """
        
        parserstate._transitionset = t
    
    
        
    def advance(self, parserstate, action):
        SHIFT = self.mappings['action']['Shift']
        LEFTARC = self.mappings['action']['Left-Arc']
        RIGHTARC = self.mappings['action']['Right-Arc']
        

        RELS = len(self.mappings['rel'])
        cand = parserstate.transitionset()

       
        
        if isinstance(action, int):
           a, rel = self.tuple_trans_from_int(cand, action)
           
           #print('se recupera',a,rel)
           
        else:
           rel = action[-1]
           a = action[:-1]

        list1 = parserstate.list1
        list2 = parserstate.list2
        buf = parserstate.buf
        
        """print 'lista1'
        print list1
        print 'lista2'
        print list2
        print 'buffer'
        print buf"""
        
        if a[0] == LEFTARC:
            n = len(list1)-1
            si = a[1] 
            #print('LA', si)
            parserstate.head[list1[n-si]] = [buf[0], rel]
            parserstate.list2 = list1[(n-si):]+list2
            parserstate.list1 = list1[:(n-si)]
        elif a[0] == RIGHTARC:
            n = len(list1)-1
            si = a[1] 
            #print('RA', si)
            parserstate.head[buf[0]] = [list1[n-si], rel]
            parserstate.list2 = list1[(n-si):]+list2
            parserstate.list1 = list1[:(n-si)]
        
        elif a[0] == SHIFT:# or len(list1) == 1:
            #print 'SH'
            parserstate.list1 = list1+list2+[buf[0]]
            parserstate.list2 = [];
            parserstate.buf = buf[1:]
            
        """#print 'DESPUES ADVANCE sobre'
        #print 'lista1'
        #print parserstate.list1
        #print 'lista2'
        #print parserstate.list2
        #print 'buffer'
        #print parserstate.buf    """
        
        self._preparetransitionset(parserstate)

    def goldtransition(self, parserstate, goldrels=None):
        SHIFT = self.mappings['action']['Shift']
        LEFTARC = self.mappings['action']['Left-Arc']
        RIGHTARC = self.mappings['action']['Right-Arc']
        

        goldrels = goldrels or parserstate.goldrels
        list1 = parserstate.list1
        list2 = parserstate.list2
        buf = parserstate.buf
        head = parserstate.head

        r = buf[0]
        addedArc = False
        
        if len(list1) == 0:
            a = (SHIFT, -1, -1)
            return a
            
        for si in xrange(len(list1)):
            n =len(list1)-1
            li = n-si
            l = list1[li]     
            if l in goldrels[r]:
                rel = goldrels[r][l]
                a = (LEFTARC, si, rel)
                addedArc = True
                #print('LA', si, li)
                break
            elif r in goldrels[l]:
                rel = goldrels[l][r]
                a = (RIGHTARC, si, rel)
                addedArc = True
                #print('RA', si, li)
                break
            ###print 'RA'
       
        if not addedArc:
            a = (SHIFT, -1, -1)
            #print 'SH'
            ###print 'NA'

        ###print 'applyied tran'
        ###print a    
        return a

    def trans_to_str(self, t, state, pos, fpos=None):
        SHIFT = self.mappings['action']['Shift']
        LEFTARC = self.mappings['action']['Left-Arc']
        RIGHTARC = self.mappings['action']['Right-Arc']
        if t[0] == SHIFT:
            if fpos is None:
                return "Shift\t%s" % (pos[state.buf[0]])
            else:
                return "Shift\t%s\t%s" % (pos[state.buf[0]], fpos[state.buf[0]])
        elif t[0] == LEFTARC:
            return "Left-Arc\t%d\t%s" % (t[1]+1, self.invmappings['rel'][t[2]])
        elif t[0] == RIGHTARC:
            return "Right-Arc\t%d\t%s" % (t[1]+1, self.invmappings['rel'][t[2]])
        
    @classmethod
    def trans_from_line(self, line):
        if line[0] == 'Left-Arc':
            fields = { 'action':line[0], 'n':int(line[1]), 'rel':line[2] }
        elif line[0] == 'Right-Arc':
            fields = { 'action':line[0], 'n':int(line[1]), 'rel':line[2] }
        elif line[0] == 'Shift':
            fields = { 'action':line[0], 'pos':line[1] }
            if len(line) > 2:
                fields['fpos'] = line[2]
        else:
            raise ValueError(line[0])
        return fields
    

    def tuple_trans_to_int(self, cand, t, num_la=0, num_ra=0,num_la_total=0):
        SHIFT = self.mappings['action']['Shift']
        LEFTARC = self.mappings['action']['Left-Arc']
        RIGHTARC = self.mappings['action']['Right-Arc']
        

        RELS = len(self.mappings['rel'])

        #print 'trans2int____'
        #print('t',t)
        #print ('size RELS',RELS)

        #print('num_la',num_la)
        #print('num_ra',num_ra)

        base = 0
        if t[0] == SHIFT:
            return 0

        if cand[0][0] == SHIFT:
            base = 1

        if t[0] == LEFTARC:
            return base + num_la*RELS + t[2]
        
        #if len(cand) > 1 and cand[1][0] == LEFTARC:
        #    print 'no deberia ejecutarse'
            
            
        #base += num_la*RELS
        #base += RELS

        if t[0] == RIGHTARC:
            return base + num_la_total*RELS + num_ra*RELS + t[2]
            #return base + t[2]

    def tuple_trans_from_int(self, cand, action):
        
        
        SHIFT = self.mappings['action']['Shift']
        LEFTARC = self.mappings['action']['Left-Arc']
        RIGHTARC = self.mappings['action']['Right-Arc']
        RELS = len(self.mappings['rel'])
        rel = -1
        
        if cand[0][0] == SHIFT:
            if action == 0:
                a = cand[0]
            else:
                a = cand[(action - 1) / RELS + 1]
                rel = (action - 1) % RELS
        else:
            a = cand[action / RELS]
            rel = action % RELS

        return a, rel
    
    
class Covington2(TransitionSystem):
    #mostrar= True
    mostrar= False
    @classmethod
    def actions_list(self):
        return [ 'Shift', 'NoArc', 'Left-Arc', 'Right-Arc']

    def create_cycles(self, parserstate, h, d):
        head = parserstate.head
        ##print('head',h)
        ##print('dep',d)
        n = h
        
        if n == d:
            #print 'cycle' 
            return True 
        
        while n > 0:
            ##print('n',n)
            n = head[n][0]
            if n == d:
                #print 'cycle' 
                return True 
        #exit()    
        return False

    def _preparetransitionset(self, parserstate):
        SHIFT = self.mappings['action']['Shift']
        NOARC = self.mappings['action']['NoArc']
        LEFTARC = self.mappings['action']['Left-Arc']
        RIGHTARC = self.mappings['action']['Right-Arc']
        
        list1, list2, buf, head = parserstate.list1, parserstate.list2, parserstate.buf, parserstate.head

        t = []
        
        if len(buf) != 0:
            
            if len(list1) == 0:
                t += [(SHIFT, -1)]
            else:  
                t += [(SHIFT, -1)]
                t += [(NOARC, 0)]
                if list1[len(list1)-1] != 0 and head[list1[len(list1)-1]][0] < 0 and not self.create_cycles(parserstate, head[buf[0]][0], list1[len(list1)-1]):
                    t += [(LEFTARC, 0)]
            
                if head[buf[0]][0] < 0 and not self.create_cycles(parserstate, head[list1[len(list1)-1]][0], buf[0]):
                    t += [(RIGHTARC, 0)]
                
        if self.mostrar:
            print '======================================================' 
            print 'allowed trans'
            print t    
            print head
        """print 'para config'
        print 'lista1'
        print list1
        print 'lista2'
        print list2
        print 'buffer'
        print buf"""
        
        
        parserstate._transitionset = t
    
    
        
    def advance(self, parserstate, action):
        SHIFT = self.mappings['action']['Shift']
        NOARC = self.mappings['action']['NoArc']
        LEFTARC = self.mappings['action']['Left-Arc']
        RIGHTARC = self.mappings['action']['Right-Arc']
        

        RELS = len(self.mappings['rel'])
        cand = parserstate.transitionset()

       
         
        if isinstance(action, int):
           #print('llaman', cand) 
           a, rel = self.tuple_trans_from_int(cand, action)
        else:
           rel = action[-1]
           a = action[:-1]

        list1 = parserstate.list1
        list2 = parserstate.list2
        buf = parserstate.buf
  
        if self.mostrar:
            print 'USAN ADVANCE sobre'
            print 'lista1'
            print list1
            print 'lista2'
            print list2
            print 'buffer'
            print buf
        
        
        if a[0] == LEFTARC:
            if self.mostrar:
                print('LA',a,rel)
            n = len(list1)-1 
            parserstate.head[list1[n]] = [buf[0], rel]
            parserstate.list2 = [list1[n]]+list2
            parserstate.list1 = list1[:n]
        elif a[0] == RIGHTARC:
            if self.mostrar:
                print('RA',a,rel)
            n = len(list1)-1 
            parserstate.head[buf[0]] = [list1[n], rel]
            parserstate.list2 = [list1[n]]+list2
            parserstate.list1 = list1[:n]
        
        elif a[0] == SHIFT:# or len(list1) == 1:
            if self.mostrar:
                print('SH',a)
            parserstate.list1 = list1+list2+[buf[0]]
            parserstate.list2 = [];
            parserstate.buf = buf[1:]
        elif a[0] == NOARC:
            if self.mostrar:
                print('NA',a)
            n = len(list1)-1
            parserstate.list2 = [list1[n]]+list2
            parserstate.list1 = list1[:n]
            
        """#print 'DESPUES ADVANCE sobre'
        #print 'lista1'
        #print parserstate.list1
        #print 'lista2'
        #print parserstate.list2
        #print 'buffer'
        #print parserstate.buf    """
        
        self._preparetransitionset(parserstate)

    def goldtransition(self, parserstate, goldrels=None):
        SHIFT = self.mappings['action']['Shift']
        NOARC = self.mappings['action']['NoArc']
        LEFTARC = self.mappings['action']['Left-Arc']
        RIGHTARC = self.mappings['action']['Right-Arc']
        

        goldrels = goldrels or parserstate.goldrels
        list1 = parserstate.list1
        list2 = parserstate.list2
        buf = parserstate.buf
        head = parserstate.head

        r = buf[0]
        addedArc = False
        noleftchildren = True
        for x in list1:
            if x in goldrels[r]:
                noleftchildren = False
                break    
        
        
        norighthead = True
        for x in list1:
            if r in goldrels[x]:
                norighthead = False
                break
        
        
        
        if len(list1) == 0:
            a = (SHIFT, -1, -1)
            return a
            
        
        l = list1[len(list1)-1]     
        if l in goldrels[r]:
            rel = goldrels[r][l]
            a = (LEFTARC, 0, rel)
            ###print 'LA'
        elif r in goldrels[l]:
            rel = goldrels[l][r]
            a = (RIGHTARC, 0, rel)
            ###print 'RA'
        elif norighthead and noleftchildren:
            a = (SHIFT, -1, -1)
            ###print 'SH'
        else:
            a = (NOARC, 0, 1)#no hay REL para NOARC
            ###print 'NA'

        ###print 'applyied tran'
        ###print a    
        return a

    def trans_to_str(self, t, state, pos, fpos=None):
        SHIFT = self.mappings['action']['Shift']
        NOARC = self.mappings['action']['NoArc']
        LEFTARC = self.mappings['action']['Left-Arc']
        RIGHTARC = self.mappings['action']['Right-Arc']
        if t[0] == SHIFT:
            if fpos is None:
                return "Shift\t%s" % (pos[state.buf[0]])
            else:
                return "Shift\t%s\t%s" % (pos[state.buf[0]], fpos[state.buf[0]])
        elif t[0] == LEFTARC:
            return "Left-Arc\t%d\t%s" % (t[1]+1, self.invmappings['rel'][t[2]])
        elif t[0] == RIGHTARC:
            return "Right-Arc\t%d\t%s" % (t[1]+1, self.invmappings['rel'][t[2]])
        elif t[0] == NOARC:
            #return "NoArc"
            return "NoArc\t%d\t%s" % (t[1]+1, self.invmappings['rel'][t[2]])

    @classmethod
    def trans_from_line(self, line):
        if line[0] == 'Left-Arc':
            fields = { 'action':line[0], 'n':int(line[1]), 'rel':line[2] }
        elif line[0] == 'Right-Arc':
            fields = { 'action':line[0], 'n':int(line[1]), 'rel':line[2] }
        elif line[0] == 'Shift':
            fields = { 'action':line[0], 'pos':line[1] }
            if len(line) > 2:
                fields['fpos'] = line[2]
        elif line[0] == 'NoArc':
            #fields = { 'action':line[0] }
            fields = { 'action':line[0], 'n':int(line[1]), 'rel':line[2] }        
        else:
            raise ValueError(line[0])
        return fields
    

    def tuple_trans_to_int(self, cand, t):
        SHIFT = self.mappings['action']['Shift']
        NOARC = self.mappings['action']['NoArc']
        LEFTARC = self.mappings['action']['Left-Arc']
        RIGHTARC = self.mappings['action']['Right-Arc']
        

        RELS = len(self.mappings['rel'])

        """base = 0
        
        if t[0] == NOARC:
            return base

        base += 1
        if t[0] == SHIFT:
            return base

        base += 1

        if t[0] == LEFTARC:
            return base + t[2]

        base += RELS

        if t[0] == RIGHTARC:
            return base + t[2]"""
        
        
        base = 0
        
        if t[0] == SHIFT:
            return 0
        
        if cand[0][0] == SHIFT:
            base = 1
        
        if t[0] == NOARC:
            return base + t[2]
            
        if len(cand) > 1 and cand[1][0] == NOARC:
            #base = 2
            base += RELS    

        if t[0] == LEFTARC:
            return base + t[1]*RELS + t[2]
        
        if len(cand) > 2 and cand[2][0] == LEFTARC:
            base += RELS
        
        if t[0] == RIGHTARC:
            return base + t[1]*RELS + t[2]
            
            

    def tuple_trans_from_int(self, cand, action):
        
        SHIFT = self.mappings['action']['Shift']
        NOARC = self.mappings['action']['NoArc']
        LEFTARC = self.mappings['action']['Left-Arc']
        RIGHTARC = self.mappings['action']['Right-Arc']
        RELS = len(self.mappings['rel'])
        rel = -1
        
       
        """if len(cand) == 1 and action == 0:
            a = cand[0]
        
        elif len(cand) == 2 and action > 1: 
            a = 10000#NO esta permitida la accion introducida
        else:
            if cand[0][0] == SHIFT and cand[1][0] == NOARC:
                if action == 0:
                    a = cand[0]
                elif action == 1:
                    a = cand[1]    
                else:
                    #print('debe de haber menos de 2 trans',len(cand))
                    #print('cand',cand)
                    #print('action', action, 'RELS', RELS)
                    b = (action - 2) / RELS + 2
                    #print('resultado ', b)
                    
                    if b >= len(cand):
                        b -= 1
                        a = cand[b]
                        print 'CASCO'
                    else:
                        a = cand[(action - 2) / RELS + 2]
                    rel = (action - 2) % RELS
            else:
                a = cand[action / RELS]
                rel = action % RELS"""
                
                
        if cand[0][0] == SHIFT:
            if action == 0:
                a = cand[0]
            else:
                a = cand[(action - 1) / RELS + 1]
                rel = (action - 1) % RELS
        else:
            a = cand[action / RELS]
            rel = action % RELS       

        return a, rel

class DynamicCovington(TransitionSystem):
    @classmethod
    def actions_list(self):
        return [ 'NoArc', 'Shift', 'Left-Arc', 'Right-Arc']

    def create_cycles(self, parserstate, h, d):
        head = parserstate.head
        ##print('head',h)
        ##print('dep',d)
        n = h
        
        if n == d:
            #print 'cycle' 
            return True 
        
        while n > 0:
            ##print('n',n)
            n = head[n][0]
            if n == d:
                #print 'cycle' 
                return True 
        #exit()    
        return False

    def _preparetransitionset(self, parserstate):
        NOARC = self.mappings['action']['NoArc']
        SHIFT = self.mappings['action']['Shift']
        LEFTARC = self.mappings['action']['Left-Arc']
        RIGHTARC = self.mappings['action']['Right-Arc']
        
        list1, list2, buf, head = parserstate.list1, parserstate.list2, parserstate.buf, parserstate.head

        t = []
        
        if len(buf) != 0:
            
            if len(list1) == 0:
                t += [(SHIFT, -1)]
            else:  
                t += [(NOARC, -1)]
                t += [(SHIFT, -1)]
                if list1[len(list1)-1] != 0 and head[list1[len(list1)-1]][0] < 0 and not self.create_cycles(parserstate, head[buf[0]][0], list1[len(list1)-1]):
                    t += [(LEFTARC,)]
            
                if head[buf[0]][0] < 0 and not self.create_cycles(parserstate, head[list1[len(list1)-1]][0], buf[0]):
                    t += [(RIGHTARC,)]
                
        ##print '======================================================'   
        #print 'allowed trans'
        #print t    
        #print head
        """##print 'para config'
        ##print 'lista1'
        ##print list1
        ##print 'lista2'
        ##print list2
        ##print 'buffer'
        ##print buf
        """
        parserstate._transitionset = t
    
    
        
    def advance(self, parserstate, action):
        NOARC = self.mappings['action']['NoArc']
        SHIFT = self.mappings['action']['Shift']
        LEFTARC = self.mappings['action']['Left-Arc']
        RIGHTARC = self.mappings['action']['Right-Arc']
        

        RELS = len(self.mappings['rel'])
        cand = parserstate.transitionset()
        
        
        #Escoge aleatoriamente una transicion que este permitidas y que tenga coste 0. Esto ha de usarse a partir de la iteracion 0
        #action = cand[random.randint(0,len(cand))]
        
        if isinstance(action, int):
           a, rel = self.tuple_trans_from_int(cand, action)
        else:
           rel = action[-1]
           a = action[:-1]

        list1 = parserstate.list1
        list2 = parserstate.list2
        buf = parserstate.buf
        
        """print 'USAN ADVANCE sobre'
        print 'lista1'
        print list1
        print 'lista2'
        print list2
        print 'buffer'
        print buf"""
        
        
        
            
        
        
        if a[0] == LEFTARC:
            #print 'LA'
            n = len(list1)-1 
            parserstate.head[list1[n]] = [buf[0], rel]
            parserstate.list2 = [list1[n]]+list2
            parserstate.list1 = list1[:n]
        elif a[0] == RIGHTARC:
            #print 'RA'
            n = len(list1)-1 
            parserstate.head[buf[0]] = [list1[n], rel]
            parserstate.list2 = [list1[n]]+list2
            parserstate.list1 = list1[:n]
        
        elif a[0] == SHIFT:# or len(list1) == 1:
            #print 'SH'
            parserstate.list1 = list1+list2+[buf[0]]
            parserstate.list2 = [];
            parserstate.buf = buf[1:]
        else:
            #print 'NA o avanza'
            n = len(list1)-1
            parserstate.list2 = [list1[n]]+list2
            parserstate.list1 = list1[:n]
            
        """ print 'DESPUES ADVANCE sobre'
        print 'lista1'
        print parserstate.list1
        print 'lista2'
        print parserstate.list2
        print 'buffer'
        print parserstate.buf"""    
        
        self._preparetransitionset(parserstate)

    def goldtransition(self, parserstate, goldrels=None):
        NOARC = self.mappings['action']['NoArc']
        SHIFT = self.mappings['action']['Shift']
        LEFTARC = self.mappings['action']['Left-Arc']
        RIGHTARC = self.mappings['action']['Right-Arc']
        

        goldrels = goldrels or parserstate.goldrels
        list1 = parserstate.list1
        list2 = parserstate.list2
        buf = parserstate.buf
        head = parserstate.head

        r = buf[0]
        addedArc = False
        noleftchildren = True
        for x in list1:
            if x in goldrels[r]:
                noleftchildren = False
                break    
        
        
        norighthead = True
        for x in list1:
            if r in goldrels[x]:
                norighthead = False
                break
        
        
        
        if len(list1) == 0:
            a = (SHIFT, -1)
            return a
            
        
        l = list1[len(list1)-1]     
        if l in goldrels[r]:
            rel = goldrels[r][l]
            a = (LEFTARC, rel)
            ###print 'LA'
        elif r in goldrels[l]:
            rel = goldrels[l][r]
            a = (RIGHTARC, rel)
            ###print 'RA'
        elif norighthead and noleftchildren:
            a = (SHIFT, -1)
            ###print 'SH'
        else:
            a = (NOARC, -1)
            ###print 'NA'
            
            
            
        #Obtener las transiciones con coste 0 y si la iteracion es superior a 0 devolver aleatoriamente una de ellas.
        #Esto es, crear 9 paths de exploracin diferentes y entrenar el modelo con cada iteracion de la 1 a la 9 con un path diferente. 
        #El comportamiento debera ser similar a un orculo dinmico (la exploracin an sera más agresiva).    

            


        ###print 'applyied tran'
        ###print a    
        return a

    def trans_to_str(self, t, state, pos, fpos=None):
        NOARC = self.mappings['action']['NoArc']
        SHIFT = self.mappings['action']['Shift']
        LEFTARC = self.mappings['action']['Left-Arc']
        RIGHTARC = self.mappings['action']['Right-Arc']
        if t[0] == SHIFT:
            if fpos is None:
                return "Shift\t%s" % (pos[state.buf[0]])
            else:
                return "Shift\t%s\t%s" % (pos[state.buf[0]], fpos[state.buf[0]])
        elif t[0] == LEFTARC:
            return "Left-Arc\t%s" % (self.invmappings['rel'][t[1]])
        elif t[0] == RIGHTARC:
            return "Right-Arc\t%s" % (self.invmappings['rel'][t[1]])
        elif t[0] == NOARC:
            return "NoArc"

    @classmethod
    def trans_from_line(self, line):
        if line[0] == 'Left-Arc':
            fields = { 'action':line[0], 'rel':line[1] }
        elif line[0] == 'Right-Arc':
            fields = { 'action':line[0], 'rel':line[1] }
        elif line[0] == 'Shift':
            fields = { 'action':line[0], 'pos':line[1] }
            if len(line) > 2:
                fields['fpos'] = line[2]
        elif line[0] == 'NoArc':
            fields = { 'action':line[0] }        
        else:
            raise ValueError(line[0])
        return fields
    

    def tuple_trans_to_int(self, cand, t):
        NOARC = self.mappings['action']['NoArc']
        SHIFT = self.mappings['action']['Shift']
        LEFTARC = self.mappings['action']['Left-Arc']
        RIGHTARC = self.mappings['action']['Right-Arc']
        

        RELS = len(self.mappings['rel'])

        base = 0
        
        if t[0] == NOARC:
            return base

        base += 1


        
        if t[0] == SHIFT:
            return base

        base += 1

        if t[0] == LEFTARC:
            return base + t[1]

        base += RELS

        if t[0] == RIGHTARC:
            return base + t[1]

    def tuple_trans_from_int(self, cand, action):
        NOARC = self.mappings['action']['NoArc']
        SHIFT = self.mappings['action']['Shift']
        LEFTARC = self.mappings['action']['Left-Arc']
        RIGHTARC = self.mappings['action']['Right-Arc']
        RELS = len(self.mappings['rel'])
        rel = -1
        
        base = 0
        if action == base:
            a = (NOARC, -1)
        base += 1

        if action == base:
            a = (SHIFT, -1)
        base += 1

        if base <= action < base + RELS:
            a = (LEFTARC,)
            rel = action - base
        base += RELS

        if base <= action < base + RELS:
            a = (RIGHTARC,)
            rel = action - base

        return a, rel







